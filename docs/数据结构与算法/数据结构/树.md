# 二叉树的基本概念
## 二叉树   
二叉树是具有相同类型的数元素的集合，包含一个根和两个子树（左子树和右子树），且两个子树也是二叉树。
节点的度：节点拥有的子树个数成为节点的度，二叉树中，节点的度最大为2。
孩子、双亲、子孙、祖先、兄弟、堂兄弟。。。
层次：即第几层。
二叉树的度：二叉树中最大的节点的度。
二叉树的深度：二叉树中节点的最大层次数。

## 满二叉树   
所有分支节点都存在左右子树，且所有叶子都在同一层次。
完全二叉树：自上往下，自左往右从1开始编号，所有节点的编号与满二叉树一致的二叉树，是一颗完全二叉树（最下层叶子集中在左边）。

## 满二叉树   
所有分支节点都存在左右子树，且所有叶子都在同一层次。一棵非空二叉树第i层，最多有2^（i-1）个节点  

## 完全二叉树   
自上往下，自左往右从1开始编号，所有节点的编号与满二叉树一致的二叉树，是一颗完全二叉树（最下层叶子集中在左边）。

## 二叉查找树    
又称为二叉排序树、二叉搜索树，具有如下性质的树为二叉查找树：   
①	要么是一棵空树，否则   
②	若任意子节点左子树非空，则左子树上所有节点的值均小于根节点的值   
③	若任意子节点的右子树非空，则右子树所有节点的值均大于根节点的值   
④	任意子节点的左右子树也分别为二叉查找树   
⑤	没有值相等的节点   

由上述可得出，平衡二叉树的中序遍历（左中右）为升序序列，如果变为右中左就是降序序列，如剑指offer第54题——给定一棵二叉搜索树，请找出其中第k大的节点。可以将使用右中左的中序遍历，遍历第k个节点返回即可。


二叉查找树的查询复杂度和二分查找一样，插入和查找的时间复杂度均为 O(logn) ，但是在最坏的情况下仍然会有 O(n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡，如下两种二叉查找树，其查找性能不可同日而语。
 

- 二叉查找树的操作主要有插入、删除、查找   
**插入**  
可以总结为，找叶子节点->插入

```
void myBinTree::Insert(int data){
	Node *tmp = new Node;
	tmp->data = data;
	tmp->lChild = tmp->rChild = nullptr;
	
	if (!m_root) {
		m_root = tmp;
		return;
	}
	Node *p = m_root;
	//找叶子节点
	while (1) {
		if (data < p->data){
			if (p->lChild) {
				p = p->lChild;
			}
			else {
				break;
			}
		}
		else{
			if (p->rChild) {
				p = p->rChild;
			}
			else {
				break;
			}
		}
	}
	//插入
	if (data < p->data) {
		p->lChild = tmp;
	}
	else{
		p->rChild = tmp;
	}
}
```

**查找**
```
Node* myBinTree::Search(int key) {
	Node *p = m_root;
	while (p) {
		if (key == p->data) {
			return p;
		}
		else if (key < p->data) {
			p = p->lChild;
		}
		else if (key > p->data) {
			p = p->rChild;
		}
	}
	return nullptr;
}
```

**删除**

```

```

## 平衡树
平衡树是任意节点的左右子树高度差小于等于1的树。常见的平衡树有B树（多路平衡搜索树——不是二叉树）、AVL树（二叉平衡搜索树）。
平衡二叉树
又称为AVL数，具有如下
