- [常考点](#常考点)
  - [数据类型](#数据类型)
  - [内存模型](#内存模型)
  - [可重入和不可重入](#可重入和不可重入)
  - [溢出](#溢出)
  - [大小端](#大小端)
  - [static](#static)
  - [const](#const)


# 常考点

## 数据类型

- 变量
变量、对象、实例是等价的，对变量的理解很重要，理解了变量，对理解内存模型很有帮助。
变量包括变量类型、变量名、变量值，其中变量名定义了该变量存储空间的大小，变量名用于标识变量存储的位置，变量值是存储空间中具体的内容。

变量类型可以是上述的基本数据类型和抽象数据类型，其实质都是存储空间大小，为了方便我们理解和使用而定义，在底层都是一样的，只是大小不一样，甚至我们可以通过类型转换来将他们任意相互转换，这是c++中最诱人优点，也是最致命的缺点。

变量值如果超出了变量类型定义的存储空间大小叫做溢出，就像桶装满了水溢出一样，这个时候，桶里的水已经不是装进去哪些了。对变量来说，溢出后的值和预想的值就不一样了，这会造成很多危害，比如死循环：

```
short len = 0;
while(len< MAX_LEN) {
    len += readFromInput(fd, buf);
    buf += len;
}
```

## 内存模型

- C语言程序内存模型  
  C语言内存模型可分为四大段，程序被加载到内存之后，就按这四段排好，供操作系统访问和写入。这四段分别是：栈区、堆区、数据区、代码区。

    - 栈区  
    栈区由操作系统自动分配和释放，按照函数先调用先入、先结束先出的顺序，存放函数指针、参数和局部变量。函数调用时入栈分配空间，函数调用结束后出栈销毁空间，所以叫局部变量，局部变量外部无法访问。

    - 堆区  
    堆区由程序代码负责分配和释放，在释放之前，只要地址指针不丢失，整个进程都能访问到这块空间。如果忘记释放，进程结束系统会自动释放。分配和释放内存由malloc和free函数完成。

    - 数据区  
    数据区用于存储全局变量、静态变量和常量，所以又可分为全局静态区和常量区，在全局静态区，初始化过的变量和未初始化的变量是分开放的，未初始化的放在.bss段中，初始化的放在.data段中。这块区域的内存在进程加载之后由系统分配，进程结束后由系统释放。

    - 代码区  
    存放函数体的二进制代码。




- C++语言程序内存模型   
C++内存可分为5个区：堆区，栈区，全局/静态区，常量区，代码区。
    - 堆区  
    堆区由程序代码负责分配和释放，在释放之前，只要地址指针不丢失，整个进程都能访问到这块空间。如果忘记释放，进程结束系统会自动释放。分配和释放有new和delete（或delete[]）运算符完成。 

    - 栈区  
    栈区由操作系统自动分配和释放，按照函数先调用先入、先结束先出的顺序，存放函数指针、参数和局部变量。函数调用时入栈分配空间，函数调用结束后出栈销毁空间，所以叫局部变量，局部变量外部无法访问。

    - 全局静态区  
    全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

    - 常量区  
    存放常量，不允许修改（通过非正当手段也可以修改）

    - 代码区  
    存放函数体的二进制代码。



## 可重入和不可重入

## 溢出

## 大小端
Big-Endian和Little-Endian的定义如下：
> Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。  
> Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。  

举一个例子，比如存储`int a=8;`a的值0x00000080在内存中的表示形式为：  
```
         大端模式                         小端模式
高地址             低字节   |   高字节                    
        | .... |           |              | .... |
        |------|           |              |------|   
        | 0x80 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x80 |
        |------|           |              |------|
        | .... |           |              | .... |
        |------|           |              |------|
低地址              高字节  |   低字节
```
可见，大端模式和字符串的存储模式类似。所以,对于上述代码,在大端模式的机器上得到的结果将是00000080。


 ## static

 - C语言中的static
  
    1. 静态局部变量  
        - 在局部作用域内声明的static变量，位于全局/静态区。
        - 只会初始化一次，如果没有显式初始化会被自动初始化为默认值。
        - 生命周期与进程一样，只能作用域内访问，重入作用域时保持上一次的值。    
    

    2.  静态全局变量
        - 定义在全局作用域内的static变量，位于全局/静态区。
        - 只会初始化一次，如果没有显式初始化会被自动初始化为默认值。
        - 生命周期与进程一样，只能本文件访问，不能被extern。
        > 静态全局变量与全局变量的区别主要是：全局变量可以通过extern在其他文件访问，静态全局变量则不能，这样防止了在不同文件定义同名变量时名字冲突。      

    3. 静态函数
       - 静态函数与静态全局变量类似，只能在本文件访问，也不能通过extern在其他文件访问。
  
- C++中static新增的作用
    1. 静态成员变量
        - static修饰的类成员变量，又叫类变量，因为这个变量属于类而不是实例，位于全局/静态区。
        - 普通成员函数也能访问类变量。
        - 静态成员变量不占类实例大小，即sizeof(class)中，不包括类变量的大小。

    2. 静态成员函数
        - static修饰的类成员函数，又叫类方法。
        - 类方法只能访问类变量和其他类方法，不能访问普通成员变量和成员函数；但普通成员函数可以访问类变量和类方法。
        - 类方法可以通过`ClassName::func()`来访问，也可以通过实例来访问。
    > 单例模式是static的一个经典的使用场景
   

## const
- 修饰普通变量
 
