
# 数据类型
- 变量
变量、对象、实例是等价的，对变量的理解很重要，理解了变量，对理解内存模型很有帮助。
变量包括变量类型、变量名、变量值，其中变量名定义了该变量存储空间的大小，变量名用于标识变量存储的位置，变量值是存储空间中具体的内容。  
变量类型可以是上述的基本数据类型和抽象数据类型，其实质都是存储空间大小，为了方便我们理解和使用而定义，在底层都是一样的，只是大小不一样，甚至我们可以通过类型转换来将他们任意相互转换，这是c++中最诱人优点，也是最致命的缺点。  
变量值如果超出了变量类型定义的存储空间大小叫做溢出，就像桶装满了水溢出一样，这个时候，桶里的水已经不是装进去哪些了。对变量来说，溢出后的值和预想的值就不一样了，这会造成很多危害，比如死循环：

```
short len = 0;
while(len< MAX_LEN) {
    len += readFromInput(fd, buf);
    buf += len;
}
```

# 内存模型

## C语言程序内存模型  
C语言内存模型可分为四大段，程序被加载到内存之后，就按这四段排好，供操作系统访问和写入。这四段分别是：栈区、堆区、数据区、代码区。
- 栈区  
栈区由操作系统自动分配和释放，按照函数先调用先入、先结束先出的顺序，存放函数指针、参数和局部变量。函数调用时入栈分配空间，函数调用结束后出栈销毁空间，所以叫局部变量，局部变量外部无法访问。

- 堆区  
堆区由程序代码负责分配和释放，在释放之前，只要地址指针不丢失，整个进程都能访问到这块空间。如果忘记释放，进程结束系统会自动释放。分配和释放内存由malloc和free函数完成。

- 数据区  
数据区用于存储全局变量、静态变量和常量，所以又可分为全局静态区和常量区，在全局静态区，初始化过的变量和未初始化的变量是分开放的，未初始化的放在.bss段中，初始化的放在.data段中。这块区域的内存在进程加载之后由系统分配，进程结束后由系统释放。

- 代码区  
存放函数体的二进制代码。


## C++语言程序内存模型   
C++内存可分为5个区：堆区，栈区，全局/静态区，常量区，代码区。
- 堆区  
堆区由程序代码负责分配和释放，在释放之前，只要地址指针不丢失，整个进程都能访问到这块空间。如果忘记释放，进程结束系统会自动释放。分配和释放有new和delete（或delete[]）运算符完成。 

- 栈区  
栈区由操作系统自动分配和释放，按照函数先调用先入、先结束先出的顺序，存放函数指针、参数和局部变量。函数调用时入栈分配空间，函数调用结束后出栈销毁空间，所以叫局部变量，局部变量外部无法访问。

- 全局静态区  
全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

- 常量区  
存放常量，不允许修改（通过非正当手段也可以修改）

- 代码区  
存放函数体的二进制代码。


# 可重入和不可重入

# 溢出

# 大小端
Big-Endian和Little-Endian的定义如下：
> Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。  
> Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。  

举一个例子，比如存储`int a=8;`a的值0x00000080在内存中的表示形式为：  
```
         大端模式                         小端模式
高地址             低字节   |   高字节                    
        | .... |           |              | .... |
        |------|           |              |------|   
        | 0x80 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x00 |
        |------|           |              |------|
        | 0x00 |           |              | 0x80 |
        |------|           |              |------|
        | .... |           |              | .... |
        |------|           |              |------|
低地址              高字节  |   低字节
```
可见，大端模式和字符串的存储模式类似。所以,对于上述代码,在大端模式的机器上得到的结果将是00000080。


 # static

 ##  C语言中的static
  
1. 静态局部变量  
- 在局部作用域内声明的static变量，位于全局/静态区。
- 只会初始化一次，如果没有显式初始化会被自动初始化为默认值。
- 生命周期与进程一样，只能作用域内访问，重入作用域时保持上一次的值。    
    

2.  静态全局变量
- 定义在全局作用域内的static变量，位于全局/静态区。
- 只会初始化一次，如果没有显式初始化会被自动初始化为默认值。
- 生命周期与进程一样，只能本文件访问，不能被extern。
  > 静态全局变量与全局变量的区别主要是：全局变量可以通过extern在其他文件访问，静态全局变量则不能，这样防止了在不同文件定义同名变量时名字冲突。      

3. 静态函数
- 静态函数与静态全局变量类似，只能在本文件访问，也不能通过extern在其他文件访问。
  
## C++中static新增的作用
1. 静态成员变量
- static修饰的类成员变量，又叫类变量，因为这个变量属于类而不是实例，位于全局/静态区。
- 普通成员函数也能访问类变量。
- 静态成员变量不占类实例大小，即sizeof(class)中，不包括类变量的大小。

2. 静态成员函数
- static修饰的类成员函数，又叫类方法。
- 类方法只能访问类变量和其他类方法，不能访问普通成员变量和成员函数；但普通成员函数可以访问类变量和类方法。
- 类方法可以通过`ClassName::func()`来访问，也可以通过实例来访问。
  > 单例模式是static的一个经典的使用场景
   

# const
1. 修饰普通变量   
在变量定义前加const关键字，可将变量声明为常量，常量在声明时必须初始化，一旦赋值就不能修改。   
```const int a=1;```   
就算通过指针修改了，最终值也不会变
```
#include  <iostream>
int main(){
   const int a=10;
   int *p=(int*)&a;
   (*p)++;
   std::cout<<"a = "<<a<<",*p = "<<*p<<std::endl;
   system("pause");
   return 0;
} 
```
输出：a = 10,*p = 11

但是如果添加了volatile修饰，则可以修改(原因还没搞明白)。
```
#include  <iostream>
int main(){
	volatile const int a=10;
	int *p=(int*)&a;
	(*p)++;
	std::cout<<"a = "<<a<<",*p = "<<*p<<std::endl;
	
	system("pause");
	return 0;
} 
```
输出：a = 11,*p = 11

2. const修饰指针  
- const修饰指针指向的内容  
表示内容不可变,简称做左定值，因为const位于'*'的左边。
```
const int *p=8;    //int const *p=8;是一样的，const都在*的边
*p=9;  //非法
```
- const修饰指针  
则指针不可变，即不可指向其他地方，但内容可变，简称右定值，因const位于'*'的右边。
```
int a = 1,b = 2;
int * const p = &a;
p = &b;   //非法，p不能指向其他地方
*p = 3;   //合法，指向的内容可变，此时*p和a都是3
``` 
- const同时修饰指针和内容
指针和指向的内容都不可变。
```
int a = 1;
const int * const p = &a;
```

3. const修饰参数和返回值
- 值传递const，则作为临时变量的参数不能被函数内修改。   
```void func (const int a){}``` 
- 指针传递const，与变量类似，也有左定值，右定值之分，如：  
```void func (const int * int a){} ```
- 引用传递const（常用），此时引用的变量不可被修改，当传入参是一个较大的自定义类型，常用这种方式来防止拷贝和被修改。
```void func (const std::string &str){} ``` 
- 返回const变量，测试发现没什么用，返回值接收对象不一定const修饰，如果不加const，返回值可以任意修改。
```
const std::string func(void){
    return "aaa";
}
int main(){
    std::string str = func();
    str = "bbb";  //合法
}
``` 
- 返回const指针   
此时返回值接收对象必须也是const，否则会报错，自然也不能被改。
```
#include  <iostream>
const int *func(void){
	int *p=new int(10); //注意不能返回局部变量的地址。
	return p;
}

int main(){
	const int *a = func();
	std::cout<<*a;
    //*a = 20;   //非法 
	std::cout<<*a; 
	return 0;
} 
``` 

4. const修饰成员函数
const不能修饰普通函数，只能修饰成员函数（位于函数参数列表后方），其目的是防止成员函数修改调用对象的值，所有不想修改调用对象的成员函数都应当声明为 const 成员函数。  
注意：const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。

```
#include  <iostream>
class cla{
public:
	void setA(int a)const{
	    m_a=a;    //非法，const成员函数不能修改成员变量。
	}
private:
	int m_a;
}; 
```

下面用一个例子说明为什么需要const成员函数
```
#include<iostream>
class Test{
public:
    Test(int a):m_a(a){}
    int GetA()const{return m_a;} 
private:
    int m_a;
};

void func(const Test& t){   //这里是传入常引用，t不允许改 
    std::cout<<t.GetA();  //此时如果GetA() 不是const函数,不允许调用
}
```
如果 `GetA()` 去掉 `const` 修饰，则 `func` 传递的 `const &t` 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以我们应该尽量将所有的不需要改变对象内容的函数都作为 const 成员函数。可以使用`const_cast`来获取对象的完全访问权限。

如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。
```
#include<iostream>
class Test{
public:
    Test(int a,int b):m_a(a),m_b(b){}
    void func()const{
        ++m_a; // 错误
        ++m_b; // 正确
    }
private:
    int m_a;
    mutable int m_b;
};
```

# volatile
与const对应，表示多变的，用来声明变量可能被某些编译器未知的因素修改，如操作系统、硬件或其他线程，以告知编译器不要对该变量进行优化。被volatile修饰的变量，每次读取都会从实际存储内存读取，每次修改也会立刻写入存储内存中。阻止了编译器对其进行优化（优化后可以从寄存器更新值以加快执行速度）。  
volatile指针，与const类似，表示该指针值是否常变。  
另外，volatile并不能保证原子性，但是在使用visual C++编译器时，volatile bool类似于atomic<bool>，所以能保证原子性。


# 类型转换
1. 隐式转换
- 表达式中低类型自动向高类型转换，可以理解为短类型自动转换为长类型。

`char->short->int->unsigned->long->unsigned long(/float)->double`
- 在符合转换条件的前提下，赋值操作，右边的值自动转化为左边的类型。
- 在符合转换条件的前提下，函数返回的值自动转换为返回值类型。
- 在符合转换条件的前提下，实参自动转化为形参的类型。

2. 强制类型转换  
均用 `Type b = (Type)a`的形式转换。

3. static_cast  
类似C风格的强制转换，进行无条件转换，静态类型转换：  
1）基类和子类之间的转换：其中子类指针转换为父类指针是安全的，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。  
2）基本数据类型转换，enum，struct，int，char，float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。  
3）把任何类型的表达式转换成void类型。
4. const_cast  
去掉类型的const或volatile属性
```
int main() {

    struct T {
        int i;
    };

    const T a;
    //a.i = 10;  //直接修改const类型，编译错误
    T &b = const_cast<T&>(a);
    b.i = 10;

    return 0;
}

volitale int c=10;
int d=const_cast<int>(c);

```
5. dynamic_cast  
有条件转换，动态类型转换，运行时检查类型安全（转换失败返回NULL）：  
1）安全的基类和子类之间的转换。  
2）必须有虚函数。  
3）相同基类不同子类之间的交叉转换，但结果返回NULL。

6. reinterpret_cast  
仅重新解释类型，但没有进行二进制的转换：  
1）转换的类型必须是一个指针，应用、算术类型、函数指针或者成员指针。  
2）在比特级别上进行转换，可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。但不能将非32bit的实例转成指针。  
3） 最普通的用途就是在函数指针类型之间进行转换。  
4） 很难保证移植性。


# 智能指针
